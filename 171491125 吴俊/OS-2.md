﻿﻿﻿﻿﻿﻿﻿﻿# ﻿练习1：分配并初始化一个进程控制块（需要编码）  ##a.请在实验报告中简要说明你的设计实现过程。###alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结 构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。  ##答：  当我们创建一个进程的时候，使用fork（）函数。这个时候，这个进程和他的父进程是一样的。所以这个进程要有唯一的一个pid。同时也需要记录这个进程的状态。  state：进程的状态   pid：进程的ID  need_ resched:是否需要重新调度释放CPU  parent：该进程的父进程  name:该进程的名字    context：用于记录调用该进程调用时的上下文  tf：记录中断  runs:定义该进程何时启用  kstack:进程的内核堆栈  mm：进程占用的内存  cr3:寄存器  flags：进程标志##b.请说明proc_struct中struct context context和struct trapframe	*tf成员变量含义和在 本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）  ##答：  ####context是进程的上下文，也就是进程执行时各个寄存器的取值。当进程切换时，进程上下文保存在其proc_struct结构体的context成员中，这样当CPU运行完将进程初始化后，再次运行时，能够恢复现场，继续执行。   struct context {  uint32_t eip;  uint32_t esp;  uint32_t ebx;  uint32_t ecx;  uint32_t edx;  uint32_t esi;  uint32_t edi;  uint32_t ebp;};   （实验的代码）  ####trap_frame包含了context的信息，除此之外，trap_frame还保存有段寄存器、中断号、错误码err和状态寄存器eflags等信息。  struct trapframe {  struct pushregs tf_regs;  uint16_t tf_gs;  uint16_t tf_padding0;  uint16_t tf_fs;  uint16_t tf_padding1;  uint16_t tf_es;  uint16_t tf_padding2;  uint16_t tf_ds;  uint16_t tf_padding3;  uint32_t tf_trapno;/* below here defined by x86 hardware */  uint32_t tf_err;  uintptr_t tf_eip;  uint16_t tf_cs;  uint16_t tf_padding4;  uint32_t tf_eflags;/* below here only when crossing rings, such as from user to kernel */  uintptr_t tf_esp;  uint16_t tf_ss;  uint16_t tf_padding5;  } __attribute__((packed));  ####区别：  从作用时机来看，context主要用于进程切换时保存进程上下文。trap_frame主要用于发生中断或异常时保存进程状态。当进程进行系统调用或发生中断时，会发生特权级转换，这时也会切换栈，因此需要保存栈信息（包括ss和esp）到trap_frame，但不需要更新context。  trap_frame与context在创建进程时所起的作用： 当创建一个新进程时，我们先分配一个进程控制块proc，并设置好其中的tf及context变量；然后，当调度器schedule调度到该进程时，首先进行上下文切换，这里关键的两个上下文信息是context.eip和context.esp，前者提供新进程的起始入口，后者保存新进程的trap_frame地址。上下文切换完毕后，CPU会跳转到新进程的起始入口。在新进程的起始入口中，根据trap_frame信息设置通用寄存器和段寄存器的值，并执行真正的处理函数。可见，tf与context共同用于进程的状态保存与恢复。  综上，由上下文切换到执行新进程的处理函数fn，中间经历了多次函数调用：forkret() -> forkrets(current->tf) -> __trapret -> kernel_thread_entry -> init_main.#练习2：为新创建的内核线程分配资源（需要编码）创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成 具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控 制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资 源。ucore一般通过do_fork实际创建新的内核线程。  do_fork的作用是，创建当前内核线程的 一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需 要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的 do_fork函数中的处理过程。它的大致执行步骤包括：调用alloc_proc，首先获得一块用户信息块。  为进程分配一个内核栈。 复制原进程的内存管理信息到新进程（但内核线程不必做此事），复制原进程上下文到新进程，将新进程添加到进程列表，唤醒新进程，返回新进程号###请在实验报告中简要说明你的设计实现过程。  int  do_ fork(uint32_ t    clone_ flags, uintptr_ t stack, struct trapframe *tf) {  int ret = -E_ NO_ FREE_ PROC;  struct proc_ struct *proc;      if (nr_ process >= MAX_ PROCESS) {          goto fork_ out;      }  ret = -E_ NO_ MEM;  if ((proc = alloc_ proc()) == NULL) {         goto fork_ out;    }   proc->parent = current;     if (setup_ kstack(proc) != 0) {  goto  bad_ fork_ cleanup_ proc;  }  if (copy_ mm(clone_ flags, proc) != 0) {  goto  bad_ fork_ cleanup_ kstack;  }  copy_thread(proc, stack, tf);  bool  intr _ flag;  local_ intr_ save(intr_ flag);  {  proc->pid = get_pid();  hash _ proc(proc);  list_ add(&proc _ list, &(proc->list_ link));  nr_ process ++;  }  local_ intr_ restore(intr_ flag);  wakeup_ proc(proc);  ret = proc->pid;  fork_out:  return ret;   bad_ fork_ cleanup_ kstack:  put_ kstack(proc);  bad_ fork_ cleanup_ proc:  kfree(proc);  goto fork_out;  }  ###请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。  可以。ucore中为新的fork的线程分配pid的函数为get_pid。每次的pid是没有被使用过的。next_ safe和last_ pid保证了这一点。#练习3：阅读代码，理解proc_run函数和它调用的函数如何完成 进程切换的。（无编码工作）###a.请在实验报告中简要说明你对proc_run函数的分析。并回答如下问题：在本实验的执行过程中，创建且运行了几个内核线程？ proc_run(struct proc_struct *proc) {    if (proc != current) {        bool intr_flag;        struct proc_struct *prev = current, *next = proc;        local_intr_save(intr_flag);        {            current = proc;            load_esp0(next->kstack + KSTACKSIZE);            lcr3(next->cr3);            switch_to(&(prev->context), &(next->context));        }        local_intr_restore(intr_flag);    }}  (1)首先判断要切换到的进程是不是当前进程，若是则不需进行任何处理。调用local_ intr_ save和local_ intr_ restore函数去使能中断，避免在进程切换过程中出现中断。更新任务状态段的esp0的值。重新加载cr3寄存器，使页目录表更新为新进程的页目录表上下文切换，把当前进程的当前各寄存器的值保存在其proc_ struct结构体的context变量中，再把要切换到的进程的proc_ struct结构体的context变量加载到各寄存器。完成上下文切换后，CPU会根据eip寄存器的值找到下一条指令的地址并执行。根据copy_ thread函数可知eip寄存器指向fork ret函数，fork ret函数的实现为fork rets(current->tf);fork rets函数的实现如下。首先是把输入变量current->tf复制给%esp，此时栈上保存了tf的值，亦即各寄存器的值。然后在trapret函数中使用popal和popl指令将栈上的内容逐一赋值给相应寄存器。最后执行iret，把栈顶的数据（也就是tf_ eip，tf_ cs和tf_ eflags）依次赋值给eip、cs和eflags寄存器。  (2)两个内核线程  ###b.语句local_ intr_ save(intr_ flag);....local_ intr_ restore(intr_ flag);	在这里有何作用?请 说明理由  避免在进程切换过程中处理中断。